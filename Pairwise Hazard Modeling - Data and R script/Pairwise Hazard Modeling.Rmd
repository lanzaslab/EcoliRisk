
---
title: "Pairwise survival analysis of E. coli transmission data"
author: "Trevor Farthing"
date: "07/11/2021"
output:
  word_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load and process survival data

This data set describes when steer in field transmission trials were shedding *Escherichia coli*. Two trials took place. One in summer 2017, and another in summer 2018. For each trial, 70 steer were brought into a feedlot pen, and 5 were inoculated with an identifiable strain of *E. coli*. Every week, fecal samples were collected from each individual and tested to see if they were actively shedding the *E. coli*. See the main article text for more details.

We're interested in assessing the risk of *E. coli* colonization in feedlot cattle, given an active E. coli outbreak, and analyzing social determinants of transmission.

The data set we refer to as "eColiShedding.csv" contains the sampling data from the trials described above. There are 1120 observations within this set. Columns are described below:

year: Year that the study took place (i.e., 2017 or 2018)
calf_id: Unique ids for calves within the study
REDI_id: Tags used to identify calves during the study (note that REDI tags were often reused for multiple individuals across different years)
innoc_date: Date that certain calves were innoculated. If NA, individuals were not innoculated with *E. coli*, and any observed *E. coli* colonization was the result of successful transmission.
Week: Unique Integer week ID within the given year that the sample was collected.
sampling_date: Date of sample collection.
shedding_fecal: Binary. If "1", individuals tested positive (i.e., > 0 CFUs) for fecal *E. coli* in a given week. If "0", they tested negative.

```{r load data}
#Load external libraries
library(contact) #version 1.2.6
library(corrplot) #version 0.84
library(data.table) #version 1.14.0
library(foreach) #version 1.5.1
library(ggplot2) #version 3.3.2
library(lubridate) #version 1.7.10
library(survival) #version 3.2-7
library(survminer) #version 0.4.9
library(transtat) #version 0.3.4

calf_transmission.raw <- read.csv("eColiShedding.csv") #pull in the multi-year transmission data 
#remove observations where individuals have an unknown shedding status 
calf_transmission.updated <- droplevels(calf_transmission.raw[-which(is.na(calf_transmission.raw$shedding_fecal) == TRUE),])
#order the data appropriately
calf_transmission.updated<- calf_transmission.updated[order(calf_transmission.updated$year, calf_transmission.updated$Week, calf_transmission.updated$calf_id),]
rownames(calf_transmission.updated) <- seq(1, nrow(calf_transmission.updated))
#Now we're going to break this down by year and arrange the columns into a form that allows for pairwise accelerated-failure-time modeling (Sharker & Kenah 2019)
calf_transmission.updated$previousInfection <- 0 #we define this variable for each calf_id to determine if individuals are susceptible. Once an individual has been infected once, they are removed from the list of susceptibles.
#we update the previousInfection column with the loop below
for(i in unique(calf_transmission.updated$calf_id)) {
  
  calfInfectedRows <- which(calf_transmission.updated$calf_id == i & calf_transmission.updated$shedding_fecal == 1)  #identify which rows contain data about when a calf id shedding
  
  if(length(calfInfectedRows) == 0){ # if a calf was never infected the loop moves on
    
    next
    
  }
  
  calfAllRows <- which(calf_transmission.updated$calf_id == i) #identify ALL rows associated with each ID
  calfInfectedRows <- calfAllRows[which(calfAllRows > min(calfInfectedRows))] #identify all weeks AFTER calves were infected (Note that this only works because the data set is ordered by week). Weeks that calves were first reported to be infected remain as 0.
  
  if(length(calfInfectedRows) == 0){ #if there are no entries here, the list moves on.
    
    next
    
  }
  
  calf_transmission.updated$previousInfection[calfInfectedRows] <- 1 #update the values in this column
  
}
#we add 52 to the week ids in 2018 (because they currently have the same IDs as those for 2017)
calf_transmission.updated$Week[which(calf_transmission.updated$year == 2018)] <- calf_transmission.updated$Week[which(calf_transmission.updated$year == 2018)] +52
#we make year into a binary variable - which appears to be a requirement of variables used by the AFT modeling procedure.
calf_transmission.updated$year_2017 <- ifelse(calf_transmission.updated$year == 2017, 1, 0)
#now we define the start and end time (in days) for each time period
calf_transmission.updated$start <- calf_transmission.updated$Week - 1  # week 1 starts on day 1 and ends at day 7. Week 2 starts on day 8 and ends at day 14. Etc.
calf_transmission.updated$stop <- calf_transmission.updated$Week # week 1 starts on day 1 and ends at day 7. Week 2 starts on day 8 and ends at day 14. Etc.
#Add week 0 and week 52 data to the data set (weeks when only the innoculated calves were infectious).
innoc_2017 <- unique(calf_transmission.updated[which(calf_transmission.updated$year == 2017 & is.na(calf_transmission.updated$innoc_date) == FALSE), match("calf_id", colnames(calf_transmission.updated))])
innoc_2018 <- unique(calf_transmission.updated[which(calf_transmission.updated$year == 2018 & is.na(calf_transmission.updated$innoc_date) == FALSE), match("calf_id", colnames(calf_transmission.updated))])
innoc_frame <- data.frame(
  
  year = c(rep(2017, 5), rep(2018, 5)), 
  calf_id = c(innoc_2017, innoc_2018),
  REDI_id = NA, #no need to import the REDI IDs
  innoc_date = c(rep("05-22-2017",5), rep("05-21-2018", 5)),
  Week = c(rep(0, 5), rep(52, 5)),
  sampling_date = NA, #no need to import
  shedding_fecal = 1,
  previousInfection = NA, #no need to import
  year_2017 = c(rep(1, 5), rep(0,5)),
  start = NA, #no need to import
  stop = NA #no need to import
)
calf_transmission.updated <- data.frame(data.table::rbindlist(list(innoc_frame, calf_transmission.updated))) #bind the data together
```

## Generate paired infection data

Here we create a dataset describing what susceptible-infectious pairs exist each week. For each week "susceptible" individuals are ones that did not have any positive fecal sample(s) in previous weeks, and "infectious" individuals are the ones actively shedding or that were shedding one week prior. Once an individual is observed to have a positive fecal sample, they are removed from the list of susceptibles moving forward (e.g., if an individual is found to be shedding *E. coli* in week 2, they are not considered susceptible in weeks 3, 4, 5, etc.).

This is NOT the ultimate data set we plan to use for analysis, but it will serve as the base of that set. Later we append covariates of interest to this set for analysis.

The following columns exist in the data frames:

id_sus: Unique ID of the susceptible individual of the pair.
start: Start time (i.e., id of the preceding week/sampling time).
stop: End time (i.e., id of the current week/sampling time).
week: Unique week ID.
shedding: Binary variable describing if individuals' fecal samples were positive.
year_2017: Binary variable describing if the trial year was 2017.
id_inf: Unique ID of the infectious individual.
infectiousNum.week: Count of the number of individuals (i.e., calves) shedding E. coli during the time period.

```{r paired data}
#now we pull susceptible individuals at each time point.
susceptible_times <- droplevels(calf_transmission.updated[which(is.na(calf_transmission.updated$innoc_date) == TRUE & calf_transmission.updated$previousInfection == 0),]) #pull observations of calves that were susceptible going into the week. (i.e., calves that were not innoculated and DID NOT test positive any previous weeks)
#now we pull the individuals that can infect others
infectious_times <- droplevels(subset(calf_transmission.updated, shedding_fecal == 1))
#now we make the pairwise shedding risk data frame
#all infectious calves are included as potential infectors.
  pairedFrame_weekList <- foreach::foreach(j = unique(susceptible_times$Week)) %do% { #for every week represented in the susceptible set, we create a list of individuals that can infect them at that time, and build a data frame detailing pairwise person-times (i.e., calf-times)
  
  susceptible_week <- droplevels(subset(susceptible_times, Week == j)) #subset by week
    
  infectious_week <- droplevels(subset(infectious_times, Week == j | Week == (j - 1))) #subset by week. 
  
  if(length(which(duplicated(infectious_week$calf_id) == TRUE)) > 0){ #remove any duplicates
    
    infectious_week <- droplevels(infectious_week[which(duplicated(infectious_week$calf_id) == FALSE),])
    
  }
  
  infectiousDyadFrame <- NULL #Create empty data frames in case there were no infectious individuals
  
  if(nrow(infectious_week) > 0){
    
    for(k in 1:nrow(susceptible_week)){
      
      dyad_time <- NULL #create an empty data frame that we will bind to
      
      for(l in 1:nrow(infectious_week)){ #we loop through the rows in infectious_week to create pairwise persontime observations
        
dyad <- data.frame(
  id_sus = as.character(susceptible_week$calf_id)[k], #id of the susceptible
  start = susceptible_week$start[k], #start of observation period
  stop = susceptible_week$stop[k], #end of observation period
  week = susceptible_week$Week[k], #week ID
  shedding = susceptible_week$shedding_fecal[k], #if the susceptible individual was observed shedding (i.e., failing)
  year_2017 = susceptible_week$year_2017[k], #binary year variable
  id_inf = as.character(infectious_week$calf_id)[l], # id of the infectious individual
  infectiousNum.week = ifelse(susceptible_week$shedding_fecal[k] == 1, nrow(infectious_week) - 1, nrow(infectious_week)) #count of infectious individuals in the contact interval (minus 1 if the susceptible here was shedding)
)
  dyad_time <- data.frame(data.table::rbindlist(list(dyad_time, dyad))) #bind these data together
      }
     
      infectiousDyadFrame <- data.frame(data.table::rbindlist(list(infectiousDyadFrame, dyad_time))) #bind these data together
     
    }
  }
  
  if(is.null(infectiousDyadFrame) == FALSE){
    infectiousDyadFrame <- infectiousDyadFrame[order(infectiousDyadFrame$id_sus, infectiousDyadFrame$id_inf),] #order appropriately
  }
  
  return(infectiousDyadFrame)
  
}
pairedFrame <- data.frame(data.table::rbindlist(pairedFrame_weekList)) #bind the weeklist into a single data frame.
if(length(which(as.character(pairedFrame$id_sus) == as.character(pairedFrame$id_inf))) > 0){ #remove instances when susceptibles have a chance to infect themselves (if it exists, which it shouldn't given how we previously subset the data).
  pairedFrame <- droplevels(pairedFrame[-which(as.character(pairedFrame$id_sus) == as.character(pairedFrame$id_inf)),]) #remove instances when susceptibles have a chance to infect themselves.
}
pairedFrame$id_sus <- as.integer(as.character(pairedFrame$id_sus)) #it seems like the susceptible ID must be numeric for later analysis using the transtat package.
```

Note that while individuals were technically monitored for 6 weeks and 10 weeks in 2017 and 2018, respectively, because we define infectious individuals as those that were observed shedding in the current and/or previous week, we can only use our intended pairwise procedure to model failure prior to the first week each year when there were 0 shedding individuals observed for two consecutive weeks. This occurred in week 6 of 2017, and did not occur in 2018. Luckily, no observed susceptibles failed in the final week of observation in 2017, so censoring animals a week early is reasonable, even if it's not ideal.

## Plot the survival data 

To better understand the data we'll plot the weekly survival each year using the survminer package. 

```{r survival_plot, warning = FALSE}


plotFrame <- pairedFrame #create a separate frame because we need to modify the start/end times of the 2018 data for plotting purposes (to set them back to 0)
plotFrame$id_week <- paste(plotFrame$id_sus, plotFrame$week, plotFrame$year_2017, sep = "_") #add this column to identify duplicated shedding events
plotFrame <- droplevels(plotFrame[-which(duplicated(plotFrame$id_week) == TRUE),]) #remove duplicates. For plotting purposes we only need to know susceptible failure times, there's no need for paired information
plotFrame$year <- ifelse(plotFrame$year_2017 == 0, 2018, 2017) #add year column
plotFrame$start[which(plotFrame$year_2017 == 0)] <- plotFrame$start[which(plotFrame$year_2017 == 0)] - 52 #subtract 52 weeks from start times in 2018
plotFrame$stop[which(plotFrame$year_2017 == 0)] <- plotFrame$stop[which(plotFrame$year_2017 == 0)] - 52 #subtract 52 weeks from stop times in 2018

shed.fit <- survfit(Surv(start, stop, shedding) ~ year, data = plotFrame) 

ggsurvplot(
  shed.fit,
  data = plotFrame,
  risk.table = TRUE,   
  pval = FALSE,      
  conf.int = FALSE, 
  xlim = c(1,9),    
  break.time.by = 1, 
  ggtheme = theme_survminer(font.legend = c(14, "plain", "black")), 
  legend = "bottom",
  legend.labs = c("2017", "2018"),
  legend.title = "",
  risk.table.y.text.col = T, 
  risk.table.y.text = FALSE, 
  xlab = "Time (weeks)"
)

```

##Add dyad-level covariates

We created a data frame describing observed contacts and social relationships between nodes in Network Creation Code.Rmd (i.e., "AFTCovariates.RData"). Here we load this data frame and merge it to the paired survival data set.

```{r dyad-level metrics}
load("AFTCovariates.RData") #load covariateFrame
colnames(covariateFrame)[match("block", colnames(covariateFrame))] <- "week" #change the name of the "block" column in covariateFrame to "week" to match the column name in pairedFrame
pairedFrame$dyadID <- paste(pairedFrame$id_sus, pairedFrame$id_inf, sep = "-") #create a merge key in the paired data set. Note that this makes susceptible individuals the from node, and infectious individuals the to node.
pairedFrame.merge <- merge(x = pairedFrame, y = covariateFrame, by = c("dyadID", "week"), all.x = TRUE) #merge the data sets
```

##Fix NAs

In 2018 there were 4 individuals (i.e., 1525, 1580, 1587, and 1709) who were not observed in contact with anyone else for weeks at a time, and RTLS point locations are generally very sparse relative to what was observd in 2017 (*see* Appendix S1). This is likely due to faulty RTLS tags and/or damaged receivers/wires. Because no contact/social information could be calculated for these individuals during these weeks, there are NAs introduced in the merged paired data set. Here, we replace NAs with 0s. Note that we are introducing 0s rather than removing survival data for two reasons: 1.) Despite the fact that animals were unobserved in the RTLS system at times, they still undoubtedly played a role in transmission. 2.) Contact and social metrics are based on observed contacts, rather than true real-world contacts (which we cannot confirm). In these time blocks we observed 0 contacts between these individuals and others, therefore inclusion of 0s here is appropriate. However, because RTLS information content varied so drastically between years, metrics based on RTLS data collected in 2018 are likely quite biased relative to 2017 metrics. This means that infection risk over the two years must be evaluated separately.

```{r fix.nas}
pairedFrame.merge$social[which(is.na(pairedFrame.merge$social) == TRUE)] <- 0 #we will use this variable to account for social relationships. Here, we replace NAs with 0. 
pairedFrame.merge$contacts.avg[which(is.na(pairedFrame.merge$contacts.avg) == TRUE)] <- 0 #we will use this variable to account for social relationships. Here, we replace NAs with 0.
pairedFrame.merge$socialDeg.from[which(is.na(pairedFrame.merge$socialDeg.from) == TRUE)] <- 0 #This variable describes the number of social relationships observed for susceptible individuals each week - or what we like to refer to as their "popularity" metric. Here, we replace NAs with 0.
pairedFrame.merge$socialDeg.to[which(is.na(pairedFrame.merge$socialDeg.to) == TRUE)] <- 0 #This variable describes the number of social relationships observed for susceptible individuals each week - or what we like to refer to as their "popularity" metric. Here, we replace NAs with 0.
```

#Reset 2018 start/stop times 

Because we will be modeling the two years separately, we need to ensure that 2018 epidemics start at time 0 as well. I know this might seem a bit strange because we added 52 to 2018 start/stop times above and now we're removing it. Adding it above just made merging covariate data frames with the survival data much easier.

Below, we also take the opportunity to assess the correlation between covariates and ensure that any colinearity issues are minimized. If any correlation is >0.50, we will select only one of the correlated covariates to include in the model. 

```{r updateTimes}
pairedFrame.merge$start[which(pairedFrame.merge$year_2017 == 0)] <- pairedFrame.merge$start[which(pairedFrame.merge$year_2017 == 0)] - 52 #subtract 52 weeks from start times in 2018
pairedFrame.merge$stop[which(pairedFrame.merge$year_2017 == 0)] <- pairedFrame.merge$stop[which(pairedFrame.merge$year_2017 == 0)] - 52 #subtract 52 weeks from stop times in 2018

#now let's plot covariates

pairedFrame.merge$week.factor <- factor(pairedFrame.merge$stop, levels = c("1","2","3","4","5","6","7","8","9","10")) #convert the numeric week IDs to factor data to allow for the creation of box-and-whisker plots

correlationFrame_2017 <- data.frame(week = pairedFrame.merge$stop[which(pairedFrame.merge$year_2017 == 1)], contacts = pairedFrame.merge$contacts.avg[which(pairedFrame.merge$year_2017 == 1)], social = pairedFrame.merge$social[which(pairedFrame.merge$year_2017 == 1)], degree.i = pairedFrame.merge$socialDeg.to[which(pairedFrame.merge$year_2017 == 1)], degree.j = pairedFrame.merge$socialDeg.from[which(pairedFrame.merge$year_2017 == 1)]) #pull the data for 2017

correlationFrame_2018 <- data.frame(week = pairedFrame.merge$stop[which(pairedFrame.merge$year_2017 == 0)], contacts = pairedFrame.merge$contacts.avg[which(pairedFrame.merge$year_2017 == 0)], social = pairedFrame.merge$social[which(pairedFrame.merge$year_2017 == 0)], degree.i = pairedFrame.merge$socialDeg.to[which(pairedFrame.merge$year_2017 == 0)], degree.j = pairedFrame.merge$socialDeg.from[which(pairedFrame.merge$year_2017 == 0)]) #pull the data for 2018

correlationMat_2017 <- cor(correlationFrame_2017) #create the correlation matrix for 2017

correlationMat_2018 <- cor(correlationFrame_2018) #create the correlation matrix for 2018

#plot the correlations
col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA")) #redefine color palette
corrplot::corrplot(correlationMat_2017, method="color", col= col(20), type="lower", cl.length = 5, addCoef.col = "black", tl.col="black", tl.srt=50, tl.cex = 0.9, tl.offset = 1.3, number.cex = 0.7, diag=TRUE) #plot the correlation matrix.
corrplot::corrplot(correlationMat_2018, method="color", col= col(20), type="lower", cl.length = 5, addCoef.col = "black", tl.col="black", tl.srt=50, tl.cex = 0.9, tl.offset = 1.3, number.cex = 0.7, diag=TRUE) #plot the correlation matrix.
```
##Lambda estimating function

Below we present a function for estimating the total weekly hazard acting on susceptible individuals (i.e., sum of all relevant pairwise hazards) from model coefficients. The function also estimates associated cumulative failure time and survival probabilities for susceptible individuals at risk each week. 

```{r lambda, echo=TRUE}

lambdaEst.week <- function(x, model, week_vec){
  
  x$week <- week_vec #ensure that the week column in x reflects the desired information vector
  covariates <- model$coefficients #pull the covariates included in the model
  modelShape <- unname(exp(covariates["log(shape)"])) #pull the shape of the Weibull distribution to be used later for survival estimation
  x$lambda <- covariates["(Intercept)"] #add the intercept value to driving infection force rate (i.e., lambda)
  
  #now we add to the lambda values depending on what covariates were included in the model.
  
  
  if (length(which(names(covariates) == "contacts.avg")) >= 1){ # if the model includes the contacts.avg covariate, we add the product of the coefficient and contacts.avg values to lambda.
    
    x$lambda <- x$lambda + (x$contacts.avg * covariates["contacts.avg"]) #add the product of the coefficient and contacts.avg values to lambda.
    
  }
  
  if (length(which(names(covariates) == "social")) >= 1){ # if the model includes the social covariate, we add the product of the coefficient and social values to lambda.
    
    x$lambda <- x$lambda + (x$social * covariates["social"]) #add the product of the coefficient and social values to lambda.
    
  }
  
  if (length(which(names(covariates) == "socialDeg.to")) >= 1){ # if the model includes the socialDeg.to covariate, we add the product of the coefficient and socialDeg.to values to lambda.
    
    x$lambda <- x$lambda + (x$socialDeg.to * covariates["socialDeg.to"]) #add the product of the coefficient and socialDeg.to values to lambda.
    
  }
  
  if (length(which(names(covariates) == "socialDeg.from")) >= 1){ # if the model includes the socialDeg.from covariate, we add the product of the coefficient and socialDeg.from values to lambda.
    
    x$lambda <- x$lambda + (x$socialDeg.from * covariates["socialDeg.from"]) #add the product of the coefficient and socialDeg.from values to lambda.
    
  }
  
  #now we add the interaction term effects
  
  
  if (length(which(names(covariates) == "contacts.avg:social")) >= 1 | length(which(names(covariates) == "social:contacts.avg")) >= 1){ # if the model includes the contacts.avg:social covariate, we add the product of the coefficient and contacts.avg:social values to lambda.
    
    if (length(which(names(covariates) == "contacts.avg:social")) >= 1){
      x$lambda <- x$lambda + (x$contacts.avg * x$social * covariates["contacts.avg:social"]) #add the product of the coefficient and contacts.avg:social values to lambda.
    }
    if (length(which(names(covariates) == "social:contacts.avg")) >= 1){
      x$lambda <- x$lambda + (x$contacts.avg * x$social * covariates["social:contacts.avg"]) #add the product of the coefficient and contacts.avg:social values to lambda.
    }
    
  }
  
  x$lambda <- exp(x$lambda) #finally, we exponentiate as we should
  
  perCapita.total <- aggregate(lambda ~ id_sus + week, data = x, FUN = "sum") #calculate the per-capita total pairwise hazard that individuals will be colonized each week.
  
#now that we know the total hazard rate (lambda) for each individual, we can get to the estimated cumulative distribution function for susceptible individuals' failure time (i.e., F(t)_j), which denotes the probability that the time of failure for indiviual j will be on or before time t. After getting F(t)_j, we can easily transform it to S(t)_j, the probability that the individual will survive past time t.

  #We'll use the total weekly lambda in the F(t) calculation 
  #For Weibull distributions, F(t) = 1 - e^(-((lambda*t)^shape)). 
  ##Here, lambda is the weekly total hazard, t is the week, and the shape parameter is given by modelShape.
  
  perCapita.total$F_t <- 1 - ((exp(1))^(-((perCapita.total$lambda*perCapita.total$week)^modelShape))) #estimate failure time probability
  perCapita.total$S_t <- 1 - perCapita.total$F_t #estimate survival probability
  
  return(perCapita.total) #return a data frame with the calculated estimates
  
}

```

##Paired AFT modeling

Below we use the "transreg" function from the transtat package (v. 0.3.3, available at https://github.com/ekenah/transtat) to employ the parametric pairwise accelerated failure time (AFT) modeling procedure described by Sharker & Kenah (2019) & Kenah (2019) to evaluate the effects of select covariates on weekly hazard rates. We fit our paired survival data to Weibull models. We create a model fit to a Weibull distribution for each potential covariate combination of interest, then use AIC-based procedures to select the "best-fitting" model(s). We maintain that "best-fitting" model each year is the one with the greatest AIC weights (Anderson 2008). As noted above, due to differences in location data quality between 2017 and 2018 study periods, we model hazard in each year separately. 
Note that degree_infectious and degree_susceptible refer to the socialDeg.to and socialDeg.from columns in the data set, respectively. 


```{r survival, echo=TRUE, warning= FALSE}

#Generate empty vectors that will be appended with values after each model is created. These vectors will be compiled into a single data frame later on for easy sorting.
model.vec <- NULL #describes what covariates are included
aic.vec <- NULL #describes model aic
year.vec <- NULL #describes the year the data were collected
lik.vec <- NULL #describes model log-likelihood
lambda.week <- NULL #describes the total per-capita lambda (i.e., force of infection) and survival probability from infectious individuals in in a given year according to the model, aggregated by week.


#2017
#{
  
  { 
  test<-transtat::transreg(
    formula = Surv(start, stop, shedding) ~ 1,
    sus = "id_sus",
    data = droplevels(subset(pairedFrame.merge, year_2017 == 1)),
    dist = "weibull",
    xdist = NULL,
    optim_method = "Nelder-Mead"
  )
  model.vec <- c(model.vec, "NULL")
  aic.vec <- c(aic.vec,  AIC(test))
  lik.vec <- c(lik.vec, test$loglik)
  year.vec <- c(year.vec,  2017);  test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 1)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 1)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
  
}


{ 
  test<-transtat::transreg(
    formula = Surv(start, stop, shedding) ~ contacts.avg,
    sus = "id_sus",
    data = droplevels(subset(pairedFrame.merge, year_2017 == 1)),
    dist = "weibull",
    xdist = NULL,
    optim_method = "Nelder-Mead"
  )
  model.vec <- c(model.vec, "contacts")
  aic.vec <- c(aic.vec,  AIC(test))
  lik.vec <- c(lik.vec, test$loglik)
  year.vec <- c(year.vec,  2017);  test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 1)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 1)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
}

{ 
  test<-transtat::transreg(
    formula = Surv(start, stop, shedding) ~ social,
    sus = "id_sus",
    data = droplevels(subset(pairedFrame.merge, year_2017 == 1)),
    dist = "weibull",
    xdist = NULL,
    optim_method = "Nelder-Mead"
  )
  model.vec <- c(model.vec, "social")
  aic.vec <- c(aic.vec,  AIC(test))
  lik.vec <- c(lik.vec, test$loglik)
  year.vec <- c(year.vec,  2017);  test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 1)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 1)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
}

{ 
  test<-transtat::transreg(
    formula = Surv(start, stop, shedding) ~ socialDeg.from,
    sus = "id_sus",
    data = droplevels(subset(pairedFrame.merge, year_2017 == 1)),
    dist = "weibull",
    xdist = NULL,
    optim_method = "Nelder-Mead"
  )
  model.vec <- c(model.vec, "degree_susceptible")
  aic.vec <- c(aic.vec,  AIC(test))
  lik.vec <- c(lik.vec, test$loglik)
  year.vec <- c(year.vec,  2017);  test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 1)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 1)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
}

{ 
  test<-transtat::transreg(
    formula = Surv(start, stop, shedding) ~ socialDeg.to,
    sus = "id_sus",
    data = droplevels(subset(pairedFrame.merge, year_2017 == 1)),
    dist = "weibull",
    xdist = NULL,
    optim_method = "Nelder-Mead"
  )
  model.vec <- c(model.vec, "degree_infectious")
  aic.vec <- c(aic.vec,  AIC(test))
  lik.vec <- c(lik.vec, test$loglik)
  year.vec <- c(year.vec,  2017);  test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 1)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 1)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
}


{ 
  test<-transtat::transreg(
    formula = Surv(start, stop, shedding) ~ contacts.avg + social,
    sus = "id_sus",
    data = droplevels(subset(pairedFrame.merge, year_2017 == 1)),
    dist = "weibull",
    xdist = NULL,
    optim_method = "Nelder-Mead"
  )
  model.vec <- c(model.vec, "contacts + social")
  aic.vec <- c(aic.vec,  AIC(test))
  lik.vec <- c(lik.vec, test$loglik)
  year.vec <- c(year.vec,  2017);  test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 1)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 1)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
}

{ 
  test<-transtat::transreg(
    formula = Surv(start, stop, shedding) ~ contacts.avg*social,
    sus = "id_sus",
    data = droplevels(subset(pairedFrame.merge, year_2017 == 1)),
    dist = "weibull",
    xdist = NULL,
    optim_method = "Nelder-Mead"
  )
  model.vec <- c(model.vec, "contacts X social")
  aic.vec <- c(aic.vec,  AIC(test))
  lik.vec <- c(lik.vec, test$loglik)
  year.vec <- c(year.vec,  2017);  test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 1)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 1)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
}

{ 
  test<-transtat::transreg(
    formula = Surv(start, stop, shedding) ~ contacts.avg + socialDeg.to,
    sus = "id_sus",
    data = droplevels(subset(pairedFrame.merge, year_2017 == 1)),
    dist = "weibull",
    xdist = NULL,
    optim_method = "Nelder-Mead"
  )
  model.vec <- c(model.vec, "contacts + degree_infectious")
  aic.vec <- c(aic.vec,  AIC(test))
  lik.vec <- c(lik.vec, test$loglik)
  year.vec <- c(year.vec,  2017);  test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 1)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 1)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
}

{ 
  test<-transtat::transreg(
    formula = Surv(start, stop, shedding) ~ contacts.avg + socialDeg.from,
    sus = "id_sus",
    data = droplevels(subset(pairedFrame.merge, year_2017 == 1)),
    dist = "weibull",
    xdist = NULL,
    optim_method = "Nelder-Mead"
  )
  model.vec <- c(model.vec, "contacts + degree_susceptible")
  aic.vec <- c(aic.vec,  AIC(test))
  lik.vec <- c(lik.vec, test$loglik)
  year.vec <- c(year.vec,  2017);  test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 1)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 1)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
}

{ 
  test<-transtat::transreg(
    formula = Surv(start, stop, shedding) ~ social + socialDeg.to,
    sus = "id_sus",
    data = droplevels(subset(pairedFrame.merge, year_2017 == 1)),
    dist = "weibull",
    xdist = NULL,
    optim_method = "Nelder-Mead"
  )
  model.vec <- c(model.vec, "social + degree_infectious")
  aic.vec <- c(aic.vec,  AIC(test))
  lik.vec <- c(lik.vec, test$loglik)
  year.vec <- c(year.vec,  2017);  test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 1)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 1)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
}

  { 
  test<-transtat::transreg(
    formula = Surv(start, stop, shedding) ~ social + socialDeg.from,
    sus = "id_sus",
    data = droplevels(subset(pairedFrame.merge, year_2017 == 1)),
    dist = "weibull",
    xdist = NULL,
    optim_method = "Nelder-Mead"
  )
  model.vec <- c(model.vec, "social + degree_susceptible")
  aic.vec <- c(aic.vec,  AIC(test))
  lik.vec <- c(lik.vec, test$loglik)
  year.vec <- c(year.vec,  2017);  test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 1)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 1)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
}
  
  { 
  test<-transtat::transreg(
    formula = Surv(start, stop, shedding) ~ socialDeg.to + socialDeg.from,
    sus = "id_sus",
    data = droplevels(subset(pairedFrame.merge, year_2017 == 1)),
    dist = "weibull",
    xdist = NULL,
    optim_method = "Nelder-Mead"
  )
  model.vec <- c(model.vec, "degree_infectious + degree_susceptible")
  aic.vec <- c(aic.vec,  AIC(test))
  lik.vec <- c(lik.vec, test$loglik)
  year.vec <- c(year.vec,  2017);  test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 1)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 1)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
}
  
  { 
  test<-transtat::transreg(
    formula = Surv(start, stop, shedding) ~ contacts.avg + social + socialDeg.to,
    sus = "id_sus",
    data = droplevels(subset(pairedFrame.merge, year_2017 == 1)),
    dist = "weibull",
    xdist = NULL,
    optim_method = "Nelder-Mead"
  )
  model.vec <- c(model.vec, "contacts + social + degree_infectious")
  aic.vec <- c(aic.vec,  AIC(test))
  lik.vec <- c(lik.vec, test$loglik)
  year.vec <- c(year.vec,  2017);  test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 1)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 1)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
} 
  
  { 
  test<-transtat::transreg(
    formula = Surv(start, stop, shedding) ~ contacts.avg*social + socialDeg.to,
    sus = "id_sus",
    data = droplevels(subset(pairedFrame.merge, year_2017 == 1)),
    dist = "weibull",
    xdist = NULL,
    optim_method = "Nelder-Mead"
  )
  model.vec <- c(model.vec, "contacts X social + degree_infectious")
  aic.vec <- c(aic.vec,  AIC(test))
  lik.vec <- c(lik.vec, test$loglik)
  year.vec <- c(year.vec,  2017);  test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 1)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 1)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
} 
 
  { 
  test<-transtat::transreg(
    formula = Surv(start, stop, shedding) ~ contacts.avg + social + socialDeg.from,
    sus = "id_sus",
    data = droplevels(subset(pairedFrame.merge, year_2017 == 1)),
    dist = "weibull",
    xdist = NULL,
    optim_method = "Nelder-Mead"
  )
  model.vec <- c(model.vec, "contacts + social + degree_susceptible")
  aic.vec <- c(aic.vec,  AIC(test))
  lik.vec <- c(lik.vec, test$loglik)
  year.vec <- c(year.vec,  2017);  test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 1)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 1)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
} 
  
  { 
  test<-transtat::transreg(
    formula = Surv(start, stop, shedding) ~ contacts.avg*social + socialDeg.from,
    sus = "id_sus",
    data = droplevels(subset(pairedFrame.merge, year_2017 == 1)),
    dist = "weibull",
    xdist = NULL,
    optim_method = "Nelder-Mead"
  )
  model.vec <- c(model.vec, "contacts X social + degree_susceptible")
  aic.vec <- c(aic.vec,  AIC(test))
  lik.vec <- c(lik.vec, test$loglik)
  year.vec <- c(year.vec,  2017);  test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 1)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 1)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
} 
 
  { 
  test<-transtat::transreg(
    formula = Surv(start, stop, shedding) ~ contacts.avg + socialDeg.to + socialDeg.from,
    sus = "id_sus",
    data = droplevels(subset(pairedFrame.merge, year_2017 == 1)),
    dist = "weibull",
    xdist = NULL,
    optim_method = "Nelder-Mead"
  )
  model.vec <- c(model.vec, "contacts + degree_infectious + degree_susceptible")
  aic.vec <- c(aic.vec,  AIC(test))
  lik.vec <- c(lik.vec, test$loglik)
  year.vec <- c(year.vec,  2017);  test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 1)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 1)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
} 
  
  { 
  test<-transtat::transreg(
    formula = Surv(start, stop, shedding) ~ social + socialDeg.to + socialDeg.from,
    sus = "id_sus",
    data = droplevels(subset(pairedFrame.merge, year_2017 == 1)),
    dist = "weibull",
    xdist = NULL,
    optim_method = "Nelder-Mead"
  )
  model.vec <- c(model.vec, "social + degree_infectious + degree_susceptible")
  aic.vec <- c(aic.vec,  AIC(test))
  lik.vec <- c(lik.vec, test$loglik)
  year.vec <- c(year.vec,  2017);  test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 1)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 1)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
} 
  
  
  {
  test<-transtat::transreg(
    formula = Surv(start, stop, shedding) ~ contacts.avg + social + socialDeg.to + socialDeg.from,
    sus = "id_sus",
    data = droplevels(subset(pairedFrame.merge, year_2017 == 1)),
    dist = "weibull",
    xdist = NULL,
    optim_method = "Nelder-Mead"
  )
  model.vec <- c(model.vec, "contacts + social + degree_infectious + degree_susceptible")
  aic.vec <- c(aic.vec,  AIC(test))
  lik.vec <- c(lik.vec, test$loglik)
  year.vec <- c(year.vec,  2017);  test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 1)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 1)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
}  
  
  {
  test<-transtat::transreg(
    formula = Surv(start, stop, shedding) ~ contacts.avg*social + socialDeg.to + socialDeg.from,
    sus = "id_sus",
    data = droplevels(subset(pairedFrame.merge, year_2017 == 1)),
    dist = "weibull",
    xdist = NULL,
    optim_method = "Nelder-Mead"
  )
  model.vec <- c(model.vec, "contacts X social + degree_infectious + degree_susceptible")
  aic.vec <- c(aic.vec,  AIC(test))
  lik.vec <- c(lik.vec, test$loglik)
  year.vec <- c(year.vec,  2017);  test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 1)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 1)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
}  
  
 #}

#2018

#{
  
  { 
    test<-transtat::transreg(
      formula = Surv(start, stop, shedding) ~ 1,
      sus = "id_sus",
      data = droplevels(subset(pairedFrame.merge, year_2017 == 0)),
      dist = "weibull",
      xdist = NULL,
      optim_method = "Nelder-Mead"
    )
    model.vec <- c(model.vec, "NULL")
    aic.vec <- c(aic.vec,  AIC(test))
    lik.vec <- c(lik.vec, test$loglik)
    year.vec <- c(year.vec,  2018); test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 0)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 0)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
  }
  
  { 
    test<-transtat::transreg(
      formula = Surv(start, stop, shedding) ~ contacts.avg,
      sus = "id_sus",
      data = droplevels(subset(pairedFrame.merge, year_2017 == 0)),
      dist = "weibull",
      xdist = NULL,
      optim_method = "Nelder-Mead"
    )
    model.vec <- c(model.vec, "contacts")
    aic.vec <- c(aic.vec,  AIC(test))
    lik.vec <- c(lik.vec, test$loglik)
    year.vec <- c(year.vec,  2018); test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 0)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 0)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
  }
  
  { 
    test<-transtat::transreg(
      formula = Surv(start, stop, shedding) ~ social,
      sus = "id_sus",
      data = droplevels(subset(pairedFrame.merge, year_2017 == 0)),
      dist = "weibull",
      xdist = NULL,
      optim_method = "Nelder-Mead"
    )
    model.vec <- c(model.vec, "social")
    aic.vec <- c(aic.vec,  AIC(test))
    lik.vec <- c(lik.vec, test$loglik)
    year.vec <- c(year.vec,  2018); test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 0)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 0)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
  }
  
  { 
    test<-transtat::transreg(
      formula = Surv(start, stop, shedding) ~ socialDeg.from,
      sus = "id_sus",
      data = droplevels(subset(pairedFrame.merge, year_2017 == 0)),
      dist = "weibull",
      xdist = NULL,
      optim_method = "Nelder-Mead"
    )
    model.vec <- c(model.vec, "degree_susceptible")
    aic.vec <- c(aic.vec,  AIC(test))
    lik.vec <- c(lik.vec, test$loglik)
    year.vec <- c(year.vec,  2018); test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 0)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 0)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
  }
  
  { 
    test<-transtat::transreg(
      formula = Surv(start, stop, shedding) ~ socialDeg.to,
      sus = "id_sus",
      data = droplevels(subset(pairedFrame.merge, year_2017 == 0)),
      dist = "weibull",
      xdist = NULL,
      optim_method = "Nelder-Mead"
    )
    model.vec <- c(model.vec, "degree_infectious")
    aic.vec <- c(aic.vec,  AIC(test))
    lik.vec <- c(lik.vec, test$loglik)
    year.vec <- c(year.vec,  2018); test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 0)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 0)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
  }
  
  { 
    test<-transtat::transreg(
      formula = Surv(start, stop, shedding) ~ contacts.avg + social,
      sus = "id_sus",
      data = droplevels(subset(pairedFrame.merge, year_2017 == 0)),
      dist = "weibull",
      xdist = NULL,
      optim_method = "Nelder-Mead"
    )
    model.vec <- c(model.vec, "contacts + social")
    aic.vec <- c(aic.vec,  AIC(test))
    lik.vec <- c(lik.vec, test$loglik)
    year.vec <- c(year.vec,  2018); test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 0)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 0)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
  }
  
  { 
    test<-transtat::transreg(
      formula = Surv(start, stop, shedding) ~ contacts.avg*social,
      sus = "id_sus",
      data = droplevels(subset(pairedFrame.merge, year_2017 == 0)),
      dist = "weibull",
      xdist = NULL,
      optim_method = "Nelder-Mead"
    )
    model.vec <- c(model.vec, "contacts X social")
    aic.vec <- c(aic.vec,  AIC(test))
    lik.vec <- c(lik.vec, test$loglik)
    year.vec <- c(year.vec,  2018); test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 0)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 0)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
  }
  
  { 
    test<-transtat::transreg(
      formula = Surv(start, stop, shedding) ~ contacts.avg + socialDeg.to,
      sus = "id_sus",
      data = droplevels(subset(pairedFrame.merge, year_2017 == 0)),
      dist = "weibull",
      xdist = NULL,
      optim_method = "Nelder-Mead"
    )
    model.vec <- c(model.vec, "contacts + degree_infectious")
    aic.vec <- c(aic.vec,  AIC(test))
    lik.vec <- c(lik.vec, test$loglik)
    year.vec <- c(year.vec,  2018); test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 0)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 0)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
  }
  
  { 
    test<-transtat::transreg(
      formula = Surv(start, stop, shedding) ~ contacts.avg + socialDeg.from,
      sus = "id_sus",
      data = droplevels(subset(pairedFrame.merge, year_2017 == 0)),
      dist = "weibull",
      xdist = NULL,
      optim_method = "Nelder-Mead"
    )
    model.vec <- c(model.vec, "contacts + degree_susceptible")
    aic.vec <- c(aic.vec,  AIC(test))
    lik.vec <- c(lik.vec, test$loglik)
    year.vec <- c(year.vec,  2018); test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 0)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 0)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
  }
  
  { 
    test<-transtat::transreg(
      formula = Surv(start, stop, shedding) ~ social + socialDeg.to,
      sus = "id_sus",
      data = droplevels(subset(pairedFrame.merge, year_2017 == 0)),
      dist = "weibull",
      xdist = NULL,
      optim_method = "Nelder-Mead"
    )
    model.vec <- c(model.vec, "social + degree_infectious")
    aic.vec <- c(aic.vec,  AIC(test))
    lik.vec <- c(lik.vec, test$loglik)
    year.vec <- c(year.vec,  2018); test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 0)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 0)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
  }
  
  { 
    test<-transtat::transreg(
      formula = Surv(start, stop, shedding) ~ social + socialDeg.from,
      sus = "id_sus",
      data = droplevels(subset(pairedFrame.merge, year_2017 == 0)),
      dist = "weibull",
      xdist = NULL,
      optim_method = "Nelder-Mead"
    )
    model.vec <- c(model.vec, "social + degree_susceptible")
    aic.vec <- c(aic.vec,  AIC(test))
    lik.vec <- c(lik.vec, test$loglik)
    year.vec <- c(year.vec,  2018); test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 0)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 0)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
  }
  
  { 
    test<-transtat::transreg(
      formula = Surv(start, stop, shedding) ~ socialDeg.to + socialDeg.from,
      sus = "id_sus",
      data = droplevels(subset(pairedFrame.merge, year_2017 == 0)),
      dist = "weibull",
      xdist = NULL,
      optim_method = "Nelder-Mead"
    )
    model.vec <- c(model.vec, "degree_infectious + degree_susceptible")
    aic.vec <- c(aic.vec,  AIC(test))
    lik.vec <- c(lik.vec, test$loglik)
    year.vec <- c(year.vec,  2018); test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 0)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 0)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
  }
  
  { 
    test<-transtat::transreg(
      formula = Surv(start, stop, shedding) ~ contacts.avg + social + socialDeg.to,
      sus = "id_sus",
      data = droplevels(subset(pairedFrame.merge, year_2017 == 0)),
      dist = "weibull",
      xdist = NULL,
      optim_method = "Nelder-Mead"
    )
    model.vec <- c(model.vec, "contacts + social + degree_infectious")
    aic.vec <- c(aic.vec,  AIC(test))
    lik.vec <- c(lik.vec, test$loglik)
    year.vec <- c(year.vec,  2018); test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 0)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 0)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
  } 
  
  { 
    test<-transtat::transreg(
      formula = Surv(start, stop, shedding) ~ contacts.avg*social + socialDeg.to,
      sus = "id_sus",
      data = droplevels(subset(pairedFrame.merge, year_2017 == 0)),
      dist = "weibull",
      xdist = NULL,
      optim_method = "Nelder-Mead"
    )
    model.vec <- c(model.vec, "contacts X social + degree_infectious")
    aic.vec <- c(aic.vec,  AIC(test))
    lik.vec <- c(lik.vec, test$loglik)
    year.vec <- c(year.vec,  2018); test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 0)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 0)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
  } 
  
  { 
    test<-transtat::transreg(
      formula = Surv(start, stop, shedding) ~ contacts.avg + social + socialDeg.from,
      sus = "id_sus",
      data = droplevels(subset(pairedFrame.merge, year_2017 == 0)),
      dist = "weibull",
      xdist = NULL,
      optim_method = "Nelder-Mead"
    )
    model.vec <- c(model.vec, "contacts + social + degree_susceptible")
    aic.vec <- c(aic.vec,  AIC(test))
    lik.vec <- c(lik.vec, test$loglik)
    year.vec <- c(year.vec,  2018); test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 0)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 0)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
  } 
  
  { 
    test<-transtat::transreg(
      formula = Surv(start, stop, shedding) ~ contacts.avg*social + socialDeg.from,
      sus = "id_sus",
      data = droplevels(subset(pairedFrame.merge, year_2017 == 0)),
      dist = "weibull",
      xdist = NULL,
      optim_method = "Nelder-Mead"
    )
    model.vec <- c(model.vec, "contacts X social + degree_susceptible")
    aic.vec <- c(aic.vec,  AIC(test))
    lik.vec <- c(lik.vec, test$loglik)
    year.vec <- c(year.vec,  2018); test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 0)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 0)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
  } 
  
  { 
    test<-transtat::transreg(
      formula = Surv(start, stop, shedding) ~ contacts.avg + socialDeg.to + socialDeg.from,
      sus = "id_sus",
      data = droplevels(subset(pairedFrame.merge, year_2017 == 0)),
      dist = "weibull",
      xdist = NULL,
      optim_method = "Nelder-Mead"
    )
    model.vec <- c(model.vec, "contacts + degree_infectious + degree_susceptible")
    aic.vec <- c(aic.vec,  AIC(test))
    lik.vec <- c(lik.vec, test$loglik)
    year.vec <- c(year.vec,  2018); test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 0)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 0)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
  } 
  
  { 
    test<-transtat::transreg(
      formula = Surv(start, stop, shedding) ~ social + socialDeg.to + socialDeg.from,
      sus = "id_sus",
      data = droplevels(subset(pairedFrame.merge, year_2017 == 0)),
      dist = "weibull",
      xdist = NULL,
      optim_method = "Nelder-Mead"
    )
    model.vec <- c(model.vec, "social + degree_infectious + degree_susceptible")
    aic.vec <- c(aic.vec,  AIC(test))
    lik.vec <- c(lik.vec, test$loglik)
    year.vec <- c(year.vec,  2018); test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 0)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 0)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
  } 
  
  {
    test<-transtat::transreg(
      formula = Surv(start, stop, shedding) ~ contacts.avg + social + socialDeg.to + socialDeg.from,
      sus = "id_sus",
      data = droplevels(subset(pairedFrame.merge, year_2017 == 0)),
      dist = "weibull",
      xdist = NULL,
      optim_method = "Nelder-Mead"
    )
    model.vec <- c(model.vec, "contacts + social + degree_infectious + degree_susceptible")
    aic.vec <- c(aic.vec,  AIC(test))
    lik.vec <- c(lik.vec, test$loglik)
    year.vec <- c(year.vec,  2018); test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 0)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 0)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
  }  
  
  {
    test<-transtat::transreg(
      formula = Surv(start, stop, shedding) ~ contacts.avg*social + socialDeg.to + socialDeg.from,
      sus = "id_sus",
      data = droplevels(subset(pairedFrame.merge, year_2017 == 0)),
      dist = "weibull",
      xdist = NULL,
      optim_method = "Nelder-Mead"
    )
    model.vec <- c(model.vec, "contacts X social + degree_infectious + degree_susceptible")
    aic.vec <- c(aic.vec,  AIC(test))
    lik.vec <- c(lik.vec, test$loglik)
    year.vec <- c(year.vec,  2018); test.week <- lambdaEst.week(x = droplevels(subset(pairedFrame.merge, year_2017 == 0)), model = test, week_vec = as.numeric(as.character(pairedFrame.merge$week.factor[which(pairedFrame.merge$year_2017 == 0)]))); test.week$model <- model.vec[length(model.vec)]; test.week$year <- year.vec[length(year.vec)]; lambda.week <- data.frame(data.table::rbindlist(list(lambda.week, test.week)))
  }  

#}

```
##Generate the AIC data frame for easy sorting

Here we calculate AIC weights for models in their respective yearly set, and weekly survival estimates for susceptible individuals weighted by aforementioned AIC weights.

```{r aicFrame, echo = TRUE}

aicFrame <- data.frame(model = model.vec, year = year.vec, distr = "weibull", aic = aic.vec, lklhd = lik.vec) #combine separate vectors into a single data frame
aicFrame <- aicFrame[order(aicFrame$aic),] #order the models by aic value
rownames(aicFrame) <- seq(1:nrow(aicFrame)) #correct rownames

aicFrame.2017 <- droplevels(subset(aicFrame, year == 2017)) #subset by year
aicFrame.2017$deltaAIC <- NA #create delta AIC column
for(i in 1:nrow(aicFrame.2017)){ #fill in the delta AIC values
  aicFrame.2017$deltaAIC[i] <- abs(diff(c(aicFrame.2017$aic[i], min(aicFrame.2017$aic, na.rm = TRUE)))) #calculate difference between observation i and the minimum value. 
}
aicFrame.2017$relLiklihood <- exp(-1 * (aicFrame.2017$deltaAIC)/2) #calculate the relative AIC likelihood
aicFrame.2017$aicWt <- aicFrame.2017$relLiklihood / sum(aicFrame.2017$relLiklihood, na.rm = TRUE) #calculate AIC weight
aicFrame.2017$relWeight <- aicFrame.2017$aicWt / aicFrame.2017$aicWt[match("NULL", aicFrame.2017$model)] #quantify the support for this model relative to the NULL.

aicFrame.2017 #view the aicFrame

aicFrame.2018 <- droplevels(subset(aicFrame, year == 2018)) #subset by year
aicFrame.2018$deltaAIC <- NA #create delta AIC column
for(i in 1:nrow(aicFrame.2018)){ #fill in the delta AIC values
  aicFrame.2018$deltaAIC[i] <- abs(diff(c(aicFrame.2018$aic[i], min(aicFrame.2018$aic, na.rm = TRUE)))) #calculate difference between observation i and the minimum value. 
}
aicFrame.2018$relLiklihood <- exp(-1 * (aicFrame.2018$deltaAIC)/2) #calculate the relative AIC likelihood
aicFrame.2018$aicWt <- aicFrame.2018$relLiklihood / sum(aicFrame.2018$relLiklihood, na.rm = TRUE) #calculate AIC weight
aicFrame.2018$relWeight <- aicFrame.2018$aicWt / aicFrame.2018$aicWt[match("NULL", aicFrame.2018$model)]#quantify the support for this model relative to the NULL.

aicFrame.2018 #view the aicFrame

#Now we manage the weekly survival estimates.

lambda.week_2017 <- droplevels(subset(lambda.week, year == 2017)) #subset the lambda.week data frame by year
lambda.week_2017.merge <- merge(lambda.week_2017, aicFrame.2017, by = "model") #merge the weekly lambda estimates with aic info.
lambda.week_2017.merge$weightedS_t <- lambda.week_2017.merge$S_t*lambda.week_2017.merge$aicWt #calculate the weekly weighted survival probability 
survival.week_2017.agg <- aggregate(weightedS_t~ id_sus + week, data = lambda.week_2017.merge, FUN = "sum") #sum the weights each week
survival.week_2017.agg$year <- 2017 #add the year back in

lambda.week_2018 <- droplevels(subset(lambda.week, year == 2018)) #subset the lambda.week data frame by year
lambda.week_2018.merge <- merge(lambda.week_2018, aicFrame.2018, by = "model") #merge the weekly lambda estimates with aic info.
lambda.week_2018.merge$weightedS_t <- lambda.week_2018.merge$S_t*lambda.week_2018.merge$aicWt #calculate the weekly weighted survival probability 
survival.week_2018.agg <- aggregate(weightedS_t~ id_sus + week, data = lambda.week_2018.merge, FUN = "sum") #sum the weights each week
survival.week_2018.agg$year <- 2018 #add the year back in

survival.week.agg <- data.frame(data.table::rbindlist(list(survival.week_2017.agg, survival.week_2018.agg))) #bind back into a single data frame for easy plotting
survival.week.agg$week_factor <- factor(survival.week.agg$week, levels = c("1","2","3","4","5","6","7","8","9","10")) #make a factor column to allow for easy box-and-whisker plotting

#Let's plot the predicted survival probabilities together with observed probabilities. 

survivalFrame <- data.frame(week = c(1,2,3,4,5, 1, 2, 3, 4, 5, 6,7,8, 9,10), 
                            year = as.character(c(2017, 2017, 2017, 2017, 2017, 2018, 2018, 2018, 2018, 2018, 2018, 2018, 2018, 2018, 2018)), 
                            atRisk = c(64, 61, 32, 29, 13, 65, 33, 26, 20, 19, 16, 11, 7, 6, 6), 
                            failed.num = c(3, 29, 3, 16, 0, 32, 7, 6, 1, 3, 5, 4, 1, 0, 0)
                            ) #this data frame is pretty self explanatory. Note that the "atRisk" column denotes the number of individuals that were susceptible going into thw sampling date each week. Further, the first observation is "64" for week 1 of 2017, rather than "65" as we would expect. This is because no record exists for one individual on week 1 of 2017. This individual's colonization status was censored until week 2.

survivalFrame$survived.num <- survivalFrame$atRisk - survivalFrame$failed.num #determine the number of the at risk population that survived in a given week.

survivalFrame$proportionSurvived <- survivalFrame$survived.num/survivalFrame$atRisk #calculate the proportion that survived
survivalFrame$cumulativeProportionSurvived <- survivalFrame$survived.num/65 #calculate the proportion of the total susceptible population that survived at the time point

survival.week.agg$key <- paste(survival.week.agg$week, survival.week.agg$year, sep = "_") #create a key column for easy merging
survivalFrame$key<- paste(survivalFrame$week, survivalFrame$year, sep = "_") #create the same column in survivalFrame
survivalFrame_merge <- merge(survivalFrame, survival.week.agg, by = "key") #merge the data frames

#plot
ggplot(survivalFrame_merge, aes(x=week_factor, y= weightedS_t, color = as.character(year.y))) +
  
  ggtitle(label = "Weekly weighted survival estimates and empirical surviving proportions")  +
  
  guides(color=guide_legend(title= "")) +
  geom_boxplot(size = 0.7) +
  geom_line(aes(y = proportionSurvived), stat='summary', fun = "mean", group = 1, size = 1.3) +
  geom_point(aes(y = proportionSurvived), stat='summary', fun = "mean", size = 2, shape = 15, stroke = 1.5) +
  stat_summary(fun="median", geom="line", aes(group = 1), size = 0.7, linetype = "dashed")  + 
  ylab("Weighted survival probability estimate") +
  xlab("Time (weeks)") +
  ylim(0,1) +
  
  theme_classic() +
  theme(
    legend.position = "bottom",
    legend.title = element_text(size = 20),
    legend.spacing.x = unit(0.3, "cm"),
    #legend.spacing.y = unit(5, "cm"),
    axis.text.x=element_text(colour="black", size = 18),
    axis.text.y=element_text(colour="black", size = 18),
    legend.text = element_text(colour="black", size = 18),
    legend.key.size = unit(1, "cm"),
    axis.title.x = element_text(colour="black", size = 20,margin = margin(t = 20, r = 0, b = 0, l = 0)),
    axis.title.y = element_text(colour="black", size = 20, margin = margin(t = 0, r = 30, b = 0, l = 0)),
    text = element_text(size = 15),
    panel.background = element_rect(fill = "gray99"),
    panel.grid.major = element_line(size=1.2, colour = "white"),
    panel.grid.minor = element_line(size=1.2, colour = "white")
  )+
  facet_wrap(~survivalFrame_merge$year.x, nrow = 1, ncol = 2)



```

##Best-fitting

Let's look more closely at the best-fitting (i.e., smallest AIC value) models each year. 

```{r best fit}
#2017
{bestFitting_2017<-transtat::transreg( #in 2017, the best-fitting model was the NULL
  formula = Surv(start, stop, shedding) ~ 1,
  sus = "id_sus",
  data = droplevels(subset(pairedFrame.merge, year_2017 == 1)),
  dist = "weibull",
  xdist = NULL,
  optim_method = "Nelder-Mead"
)
}
#2018
{bestFitting_2018<-transtat::transreg( 
  formula = Surv(start, stop, shedding) ~ socialDeg.to + socialDeg.from,
  sus = "id_sus",
  data = droplevels(subset(pairedFrame.merge, year_2017 == 0)),
  dist = "weibull",
  xdist = NULL,
  optim_method = "Nelder-Mead"
)
}
```

##Ratio calculation

Kenah (2011) and the transtat::transreg help page explain that "accelerated failure time models are log-linear models for the rate parameter in the specified survival time distribution. Each coefficient can be interpreted as the log rate ratio for a one-unit increase in the corresponding covariate." Therefore to obtain the true estimated rate ratio from our best-fitting models we must exponentiate the coefficients they report. 

Below we exponentiate the coefficents and Wald 95% CIs reported by each yearly best-fitting model. 

```{r ratios}
bestFitting_2017.summ <- summary(bestFitting_2017)
bestFitting_2017.summ$table 
bestFitting_2018.summ <- summary(bestFitting_2018)
bestFitting_2018.summ$table
#Finally, we exponentiate reported values to generate the predicted weekly hazard rate ratio for all covariates.
exp(bestFitting_2017.summ$table[,1:3]) #because this is the null model, exponentiating these values is not informative.
exp(bestFitting_2018.summ$table[,1:3]) # see that all covariates are significant (the 95% CI never crosses 1)
```

##Literature cited

Anderson, D.R. 2008. Model based inference in the life sciences: a primer on evidence, pp. 88-104. Springer Science + Business Media, New York, USA. 

Kenah, E. 2011. Contact intervals, survival analysis of epidemic data, and estimation of R0. *Biostatistics* 12(3):548-566. https://dx.doi.org/10.1093%2Fbiostatistics%2Fkxq068.

Kenah, E. 2019. Pairwise survival analysis of infectious disease transmission data. In Held, L., Hens, N., O’Neil, P.D., & Wallinga, J. eds. Handbook of Infectious Disease Data Analysis, pp. 221-244. Chapman and Hall/CRC, New York, USA. 

Sharker, Y., & Kenah, E. 2019. Pairwise accelerated failure time models for infectious disease transmission with external sources of infection. Pre-print at https://arxiv.org/abs/1901.04916.


